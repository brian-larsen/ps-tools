<#
.DESCRIPTION
  This script takes as input a text file transcript of a Teams conversation and formats it to a more reader-friendly version.
  Currently, copying the content of a chat in Teams results in one of two scenarios:
    1. A large amount of metadata is gathered, causing messages to appear redundant and the transcript to be confusing.
    2. No metadata is collected at all, making it impossible to attribute messages outside of assumption through context.

  The following formatting is performed:
    - Summary lines about each message ("<first several characters of the message> by <last name>, <first name> (Department)") are removed.
    - Redundant lines indicating the name of the person who posted multiple, sequential messages are removed.
      Only the first instance of the user's name for each group of sequential messages remains, followed by the time of the post
      If a time stamp is applied to a new post by the same user, hte name and time stamp both remain.
    - Redundant lines showing the number of reactions for each reaction type are removed.
    - Lines generated by the Teams app which are irrelevant to the conversation are removed.
        E.g.  "Last read" : indicating the last message in the chat that was read by the user
              "Has context menu" : UI menu for quick response message buttons
    - Newline characters are condensed
    - A newline is inserted before each new message for readability

.NOTES
  Since there is generally no data collected when copying images, most often it appears simply as a blank line in the transcript after formatting,
  though the newline character is occasionally omitted leaving only the name of the user and time of the message.

  The newly formatted file will automatically open in the default text editor.

.INPUTS
  (optional)
  TXT input file: <filename>.txt
  - .txt file type is required

.EXAMPLE
  .\FormatTeamsChat.ps1
  .\FormatTeamsChat.ps1 ".\Teams transcript file.txt"
#>


param (
  [string]$transcriptFile
)

#-------------------------------------
# region Classes
#-------------------------------------
Add-Type -AssemblyName System.Windows.Forms

#-------------------------------------
# region Functions
#-------------------------------------
Function Get-TeamsTranscript {
  <#
  .DESCRIPTION
    Opens a File Explorer dialog for selection of an existing text file.
  #>
  $fileDialog = New-Object System.Windows.Forms.OpenFileDialog
  $fileDialog.ShowDialog() | Out-Null
  $teamsTranscript = $fileDialog.FileName
  return $teamsTranscript
}

#-------------------------------------
# region Constants
#-------------------------------------
[string]$file = $null
[regex]$byLine = ".{1,47} by (\b[\w-]+\b *)+, (\b[\w-]+\b *)+\(\b[\w= -_&]+\)(?=\r?\n)"
[regex]$sequentialPost = "(?m)(?<=\r?\n)(\r?\n)*(\b[\w-]+\b *)+, (\b[\w-]+\b *)\(\b[\w+ -_&]+\)(\r?\n)+(?!(\d{1,2}/\d{1,2}/\d{4} )?\d{1,2}:\d{1,2} [AM|PM]{2})"
[regex]$reactionCount = "(?<=\d+ [\w\s]+ reaction[s]?\.)\r?\n\d+"
[regex]$lastRead = "Last read\r?\n"
[regex]$contextMenu = "[Hh]as context menu\.*"
[regex]$newComment = "^(\b[\w-]+\b\s*)+, (\b[\w-]+\b\s*)+\(\b[\w+ -_&]+\)$"
[regex]$condenseBlankLines = "(\r?\n){3,}"
[bool]$formatComplete = $false

#-------------------------------------
# region Formatting Actions
#-------------------------------------

$formatTranscript = {
  # Select the target file to format, either passed as a parameter or selected using the file dialog.

  # Check for a file name passed as a parameter
  if (-not [string]::IsNullOrEmpty($transcriptFile)) {
    # Make sure the path is valid
    if (Test-Path -Path $transcriptFile) { [string]$file = $transcriptFile }
    # Prompt user to select a file using the dialog window
    else {
      Write-Output "Invalid file path - please select a file."
      [string]$file = Get-TeamsTranscript
    }
  }
  # Prompt for a file using the dialog window
  else {
    [string]$file = Get-TeamsTranscript
  }

  # Exit the script if no file is selected
  if ([string]::IsNullOrEmpty($file)) {
    Write-Warning "No file selected -- Exiting."
    Break
  }

  # Make sure the specified file is a text file
  if (-not ([System.IO.Path]::GetExtension($file) -eq '.txt')) {
    Write-Warning "Invalid file extension. Must be '.txt' file. `nExiting"
    Break
  }

  Write-Output "Transcript file: " $file

  # Replace content that matches regex rules defined above
  $content = Get-Content -Raw -Path $file
  $null = Switch -regex ($content) {
    # Remove all preview lines containing "by <userLast>, [<userFirst>] (<Department>)".
    $byLine { $content = $content -replace $byLine, "" }

    # Remove redundant commenter's name if they poseted sequential messages (user name and dept. not followed by time stamp).
    # Commenter's name remains if their message is being responded to (username and dept. followed by both date and time).
    $sequentialPost { $content = $content -replace $sequentialPost, "" }

    # Remove redundant digit following reaction indicators.
    $reactionCount { $content = $content -replace $reactionCount, "" }

    # Remove line that says "Last read" if it exists. It simply indicates the last line of the chat that was read by the signed-in Teams user.
    $lastRead { $content = $content -replace $lastRead, "" }

    # Remove 'Has context menu" line
    $contextMenu { $content = $content -replace $contextMenu, "" }

    default { $_ }
  }
  Set-Content -Path $file -Value $content

    (Get-Content -Path $file) |
  ForEach-Object {
    if ($_ -match $newComment) {
      ""
      $_
    }
    else { $_ }
  } | Set-Content -Path $file -Force

  # Replace multiple newlines with a single newline character.
  # Also remove blank lines at the beginning and end of the file.
  $content = ((Get-Content -Raw -Path $file) -Replace $condenseBlankLines, "`n`n").Trim()
  Set-Content -Path $file -Value $content -Force
  $formatComplete = $true
  Write-Output "Formatting complete."

  # Open the formatted file in the default text editor
  if ($formatComplete -eq $true) { Invoke-Item $file }
}

& $formatTranscript